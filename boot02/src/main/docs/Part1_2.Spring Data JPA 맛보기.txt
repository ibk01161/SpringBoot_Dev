#2. Spring Data JPA 맛보기 (boot02)
- Spring Data JPA는 JPA(Java Persistence API)라는 기술을 스프링에서 개발할 수 있도록 돕는 라이브러리, 다양한 데이터베이스에 종속적인 SQL문 없이 개발이 가능하기 때문에 개발의 생산성을 높일 수 있음

* ORM(Object Relational Mapping)
- 객체지향에서 말하는 객체와 데이터베이스에서 말하는 개체가 상당히 유사
- 객체지향과 관계형 데이터베이스를 매핑시킨다는 추상화된 개념

* JPA란?
- Java Persistence API의 약자, Java를 이용해 데이터를 관리(유지)하는 기법을 하나의 스펙으로 정리한 표준, EJB라는 기술 스펙에서 엔티티 빈이라는 데이터를 처리하는 스펙을 정한 것이 JPA의 시초
- ORM의 개념을 Java 언어에서 구현하기 위한 스펙, 기존 JDBC등을 이용해 직접 구현했던 데이터베이스 관련 작업을 대신 처리해 주는 추상화된 계층의 구현 스펙
- 데이터베이스에 대한 처리를 JPA 계층에서 처리하기 때문에 좀 더 추상화된 형태의 코드를 제작하는 것만으로 개발이 가능
- JPA 그 자체로는 스펙에 불과하기 때문에 이를 실제로 구현한 제품이나 프레임워크들의 존재가 필수적 (Servlet이라는 기술 스펙을 Tomcat에 구현한 것 처럼)
- JPA를 구현한 구현체(프로바이더) 중에서 스프링부트에서는 Hibernate라는 것을 이용 (이외에도 EclipseLink, DataNucleus 등이 있음)

* JPA의 장점
1) 데이터베이스 관련 코드에 대해 유연함을 얻을 수 있음
- 데이터베이스 변경은 기존 소스 코드에 치명적인 영향을 끼침, 데이터베이스가 변경되면 SQL이 변경되고, DAO나 서비스, 화면까지 영향을 미치게됨
- JPA를 이용하면 테이블 생성 등과 같은 작업부터 변경되는 DB설계와 JAVA설계를 한 번에 처리할 수 있음
2) 데이터베이스와 독립적인 관계
- JPA는 특정 벤더의 데이터베이스에 종속적이지 않기 때문에 데이터베이스 제품이 변경되거나 버전이 변경되는 것과 같은 일에서 자유로워질 수 있음

* JPA의 단점
1) 학습 곡선이 큼
- 기존 데이터베이스 위주 학습에 비해 새로운 기능들이 많음, 새로운 개념과 기술을 익히는 학습 곡선이 크기 때문에 적용이 어려움
2) 근본적인 객체지향 설계 사상이 반영되어야 함
- '어떻게 적합한 객체들의 관계를 작성할 것인가' 가 프로젝트의 성패를 좌우함, 이 과정에서 충분한 설계와 검토 과정을 거쳐야 함
3) 특정 데이터베이스의 강력함을 활용할 수 없다는 문제
- JPA를 이용하면 SQL 튜닝 등 작업에 제약이 생길 수 있음, native SQL 이라는 기능을 지원해 기존 SQL을 재사용 할 수 있지만, 이 경우 데이터베이스에 독립적인 개발이 불가능해 JPA의 장점을 잃는 한계를 가지게 됨

* JPA의 구조 (Application <-> JPA <-> JDBC <-> DataBase)
- JPA를 이용하면 Java로 작성된 클래스, 객체들과 데이터베이스상에 테이블, 레코드들을 자동으로 관리하게 됨, 별도 SQL을 작성할 필요 없이 원하는 객체지향의 구조를 설계하는 것만으로 모든 개발을 끝낼 수 있음
- 중간에 JPA의 역할이 중요함, Java 쪽 메모리 상태와 데이터베이스의 상태를 관리해야 하기 때문에 별도 용어가 있음


* 엔티티(Entity), 엔티티 매니저(EntityManager)
- 엔티티 : 데이터베이스상에서 데이터로 관리하는 대상을 의미 (상품, 회사, 직원 과 같이 명사이면서 업무와 관련된 데이터를 엔티티로 규정)
	 데이터베이스에서는 엔티티를 위해서 일반적으로 테이블을 설계하고, 데이터를 추가하는데 이렇게 추가된 데이터는 '인스턴스', '레코드' 라는 용어로 호칭
	 JPA에서는 Java를 이용해 이러한 엔티티들을 관리하기 때문에 엔티티 타입의 존재는 클래스가 됨(JPA에서 '하나의 엔티티 타입을 생성한다' 라는 의미는 '하나의 클래스'를 작성한다.)
	 주의할 점은 '엔티티' 라는 용어가 때로는 클래스를 의미할 경우도 있지만, 때로는 인스턴스를 의미하는 경우도 있음 ('회원 엔티티'가 회원 클래스를 의미하는 경우도 있고, 회원 클래스에서 생성된 인스턴스를 의미하는 경우도 있음)
- 엔티티 매니저 : 엔티티 객체들을 관리하는 역할 (관리 = LIfe Cycle), 엔티티 매니저는 자신이 관리해야 하는 엔티티 객체들을 '영속 컨텍스트(Persistence Context)' 라는 곳에 넣어두고, 객체들의 생사를 관리하게 됨

* 영속 컨텍스트(Persistence Context)와 엔티티 객체
- 영속 컨텍스트는 JPA가 엔티티 객체들을 모아두는 '공간'이라고 이해할 수 있음 (공간이나 울타리 개념)
- New(비영속) : Java 영역에 객체만 존재하고, 데이터베이스와 연동된 적 없는 상태, 엔티티 매니저의 관리하에 있는 것이 아니기 때문에 순수한 Java 객체
- Managed(영속) : 데이터베이스에 저장되고, 메모리상에서도 같은 상태로 존재하는 상태, 객체는 영속 컨텍스트에 들어가게 되고, id(PK)값을 통해 필요한 엔티티 객체를 꺼내 사용할 수 있게 됨
- Removed(삭제) : 데이터베이스상에서 삭제된 상태, 객체는 더 이상 영속 컨텍스트에 존재하지 않음
- Detached(준영속) : 영속 컨텍스트에서 엔티티 객체를 꺼내서 사용하는 상태, 준영속 상태의 객체는 고유한 id(PK)를 가지고 있지만, 아직 데이터베이스와 동기화가 이루어지지 않은 상태

* 기존의 JPA 개발과 Spring Data JPA
- 기존 Java를 공부할 때 Java에서 인터페이스를 설계하고, 이를 구현하는 클래스를 만드는 것이 일반적이지만
- Spring Data JPA는 동적으로 인터페이스를 구현하는 클래스를 만들어 내는 방식(동적 프록시_Dynamic Proxy)을 이용해 실제 클래스를 작성하지 않아도 자동으로 만들어지기 때문에 별도의 코드를 작성할 필요가 없음

* Spring Data JPA를 위한 프로젝트 생성
- 스프링부트 가장 큰 장점 중 하나가 스프링과 사용하는 라이브러리의 버전에 신경 쓸 필요가 없음 (필요한 라이브러리들의 버전을 스프링부트의 버전에 맞게 조정해 주기 때문에 설정에 신경 쓰지 않고 개발 가능)
- 라이브러리(Spring Boot Dev Tools) : 자동으로 서버의 재시작을 도와줌, 이를 이용해 코드를 수정하면 자동으로 서버를 재시작해 주므로 개발 시간을 단축시켜줌

* 프로젝트 실행과 DataSource 설정
- 스프링부트에 JDBC와 같은 추가 라이브러리를 포함해서 이용했을 때 가장 큰 차이점은 실행에 제약이 있다는 점 => main()을 실행해보면 정상적으로 실행X => 원인은 스프링부트 자체가 자동으로 설정을 구성하기 때문
- 스프링부트가 동작할 때 JDBC 등과 같은 라이브러리가 포함되어 있으면 라이브러리를 이용해서 필요한 객체들을 구성하려고 하는데 이때 데이터베이스 설정이 없기 때문에 실행X => 데이터베이스 구성하고 DataSource를 지정해줘야함

* MySQL 설정
- 새로운 스키마 생성 => 새 스키마 를 사용할 새로운 사용자 계정 생성

* DataSource 설정
- DataSource에 대한 설정을 지정해 주어야 실행 됨 (여러가지 방법이 있는데 1번으로 설정)
1) 'application.properties'를 이용해 필요한 구성 설정 - application.properties에 데이터베이스 연결에 필요한 JDBC연결 설정
2) @Bean과 같은 어노테이션을 이용해서 Java 코드를 통해 필요한 객체를 구성하는 방법