#9. Spring MVC와 Web Security의 통합
- Spring MVC를 이용해 만든 기존 프로젝트에 스프링 시큐리티를 추가
1) 웹 프로젝트에서 특정 URI에 대한 접근 제한 처리 및 로그인
2) Ajax를 이용하는 호출 시 CSRF 토큰에 대한 처리

9.1. 프로젝트 구성
- 예제는 게시물 관리 시스템과 시큐리티 프로젝트를 하나로 묶는 작업
- 작성된 프로젝트의 모든 기능을 사용하기 위해 pom.xml에 추가 라이브러리들이 필요 (Thymeleaf-layout, Querydsl, Thymeleaf-security)

9.1.1. 기존 프로젝트 통합
- 프로젝트를 통합할 때 가장 우선적으로는 application.properties를 처리, 저번 프로젝트 application.properties를 그대로 복사해서 사용
- 만들어진 프로젝트에 게시물과 댓글 처리와 관련된 내용이 필요하므로 저번 프로젝트 복사
- 현재까지 복사한 프로젝트가 정상적으로 동작하는지 프로젝트를 실행시켜 확인
- 브라우저에서는 '/board/list'를 호출했을 때 정상적으로 호출되고, 로그인 경고창이 보이는 것을 확인, 경고창이 뜨는 이유는 스프링 시큐리티가 추가되고 별도 설정이 없기 때문
- 이는 스프링 부트에 자동 설정 기능이 동작하기 때문, 프로젝트 생성 시 'security' 를 추가한 상태이므로 기본 인증 처리가 설정되기 때문에 로그인 창이 보임
- 기본 인증 매니저는 'user'라는 계정을 가지고, 패스워드는 프로젝트의 로딩 시 출력되는 기본 패스워드임, 이를 이용해 로그인을 하면 정상적으로 list화면이 출력되어야 함

9.1.2. 시큐리티 설정
- 기본 계정과 패스워드를 이용해 로그인을 하고, 정상적인 화면이 나오는 것을 확인했다면, 저번 프로젝트에서 사용했던 설정을 이용해 시큐리티 설정을 추가
- 저번 프로젝트의 domain, persistence, controller, security 패키지 복사
- 코드를 통합한 이후에는 게시물 관리의 GET 방식으로 동작하는 기능들이 정상적으로 동작하는지 확인해야 함 (POST방식은 CSRF 토큰 값이 필요하므로 GET 방식을 사용해야함)
= 8장에서 스프링 시큐리티 학습에 사용했던 화면을 추가하지 않은 이유는 Thymeleaf의 레이아웃 기능 등을 적용해 새로 작성할 필요가 있기 때문

9.2. 게시물 작성 부분
- 가장 먼저 처리할 부분은 로그인한 사용자만 특정 URI에 접근이 가능하도록 설정, list는 모든 사용자가 볼 수 있도록 하고, register는 로그인한 사용자만 접근할 수 있도록 작성 (SecurityConfig를 이용해 설정)
- hasAnyRole()를 이용하면 여러 개의 Role을 설정할 수 있으므로, 하나 이상의 Role을 지정할 때 편하게 사용할 수 있음
- 프로젝트를 실행하고 새로운 게시물을 작성하는 페이지를 호출할 때 정상적으로 접근 제한이 되는지 확인 (현재 /login에 해당하는 웹 페이지는 존재하지 않으므로 templates 폴더에 login.html 추가)
- 로그인 화면에서 사용자가 정상적으로 로그인 하면 '/' 경로로 이동하게 됨 (register에서부터 처리되었다면 register로 이동하게 됨)
- 브라우저에서 register를 호출하면 정상적으로 게시물 작성 페이지로 이동됨
- 주소창에서 login을 직접 호출해 로그인을 시도하는 경우에는 Spring Security의 기본 설정에 따라 '/' 경로로 이동하게 됨, 반면에 특정 페이지에서 login으로 이동한 경우에는 로그인 후에 자동으로 기존 페이지로 이동하게 됨
- 로그인하지 않는 사용자가 브라우저에서 register를 호출하게 되면 이전과 동일하게 login 으로 이동하게 됨, 로그인 후에는 자동으로 register로 이동하는 것을 볼 수 있음

9.2.1. 게시물 작성 시 사용자 아이디 편집
- URI에 대한 접근 제어 처리가 완료되었다면, 게시물 등록 화면에서 로그인한 사용자의 아이디를 작성자의 입력란에 자동으로 처리하도록 함
- 이는 Thymeleaf-security를 이용해 처리, boards 폴더 내 register.html 내에서 Thymeleaf-security를 사용할 수 있도록 네임스페이스를 편집
- 작성자의 입력 부분은 'readonly'를 지정하고, 현재 로그인한 사용자의 uid가 출력되도록 수정
- Thymeleaf 시큐리티 관련 처리가 완료되면 현재 로그인한 사용자의 uid가 출력되는 것을 볼 수 있음
- 스프링 시큐리티가 적용되면 별도의 설정이 없는 이상 GET 방식을 제외한 POST 등의 방식으로 전송할 경우 CSRF 토큰 값이 반드시 필요
- 흥미로운 사실은 <form> 태그에 Thymeleaf의 속성을 추가하면 자동으로 'CSRF' 필터가 적용되어 있다는 점, 떄문에 직접 CSRF 값을 지정할 필요 없이 <form> 데이터를 전송할 수 있음
=>  <input type="hidden" name="_csrf" value="7025ca05-3f62-4569-b40b-c75f1551f4af">
- CSRF 토큰까지 처리된 것을 확인한 후에 게시물을 등록하면 정상적으로 새로운 게시물이 등록되는 것을 볼 수 있음

9.3. 게시물 조회
- 게시물 조회 화면에서 시큐리티 적용이 필요한 부분
1) 현재 게시물의 작성자만이 수정/삭제가 가능하도록 제어
2) 게시물의 댓글 처리 시에 대한 제어
- 댓글 처리는 Ajax를 이용해야 하므로 뒤에서 처리하고, 우선은 현재 게시물의 작성자와 현재 페이지를 보는 사용자(로그인했거나 하지 않은)가 동일한 사용자인 경우에는 '수정/삭제'를 처리할 수 있도록 제어

9.3.1. 게시물 수정/삭제 버튼의 제어
- 수정/삭제 버튼을 제어하는 방식은 화면상에서 버튼 자체를 안 보이도록 처리하는 방식, 버튼은 보이고, JavaScript를 이용해 로그인을 유도하는 방식이 일반적
- 버튼을 감추는 방식에서는 현재 사용자가 로그인을 한 사용자인지 아닌지를 구분해서 처리해야 함, view.html에 Thymeleaf-security 네임스페이스를 설정
- authentication.principal을 이용해서 현재 '익명의 사용자(anonymousUser)' 인지 '로그인 사용자(${#authentication.principal.member.uid})' 인지를 체크
- 사용자의 아이디를 uid 변수로 지정하고, 이를 이용해 th:if로 버튼이 보이도록 처리, <a> 태그에 id 속성을 추가한 것을 JavaScript 처리를 단순하게 하기 위해서 추가
- 현재 로그인한 사용자가 자신이 작성한 게시글을 조회하는 경우에는 다음과 같이 수정/삭제 버튼이 보이게 됨, 자신이 작성한 글이 아니면 하나의 버튼만 보이게 됨
- 만약 JavaScript를 이용해서 처리하고 싶다면 <a> 태그에서 th:if 부분을 삭제한 후에 작성
- 만일 현재 사용자가 로그인하지 않은 상태에서 '수정/삭제' 버튼을 클릭하면 브라우저는 '수정/삭제'가 가능한 URL로 이동하게 됨, 수정/삭제는 로그인이 필요하므로, 버튼을 클릭하면 자동으로 로그인 페이지가 뜸
- 만일 로그인한 사용자가 현재 게시물의 작성자가 아니면 다른 메세지가 보이게 됨

9.4. 게시물의 수정/삭제
- 게시물의 수정/삭제는 로그인한 사용자들만이 가능해야 하므로 SecurityConfig에 추가하거나, WebController에 @Secure를 이용해서 처리
- 컨트롤러에서 수정/삭제 작업에 시큐리티 설정이 추가되었기 때문에 시큐리티 설정이 추가되었기 때문에 로그인을 하지 않았다면 자동으로 로그인 페이지로 이동하게 됨
- 삭제 처리를 하기 위해 Delete 버튼을 클릭하면 정상적으로 처리되지 못하고 에러 메시지만 보이게 됨 (시큐리티를 이용하는 경우 CSRF 파라미터가 반드시 필요하기 때문에 에러가 남)
- 우선 modify.html에 시큐리티 관련 네임스페이스를 추가하고, form 태그 안에 CSRF 관련 태그를 추가
- 만약 직접 추가하기 싫다면 th:action을 처리해 주면 자동으로 CSRF 파라미터가 설정됨 (th:action="@{/}"), th:action을 이용하는 경우 화면상에서는 <form> 태그 부분에 <input type="hidden">으로 CSRF가 처리됨

9.5. Ajax의 시큐리티 처리
- 게시물 조회 화면 에서의 댓글은 Ajax로 처리되기 때문에 별도의 처리가 필요, 여기서 가장 신경 써야 하는 부분은 Ajax로 호출하는 작업에 CSRF 값이 같이 전송되어야 한다는 것
- 댓글에 관련된 모든 작업은 기본적으로 로그인한 사용자들만이 가능하므로, WebReplyContorller 를 수정, 댓글 관련 기능 중 등록, 수정, 삭제 작업에 시큐리티 설정을 추가

9.5.1. 댓글 추가
- 댓글 추가하는 작업은 현재 사용자가 로그인을 해야만 가능, 따라서 화면상에 댓글 추가하는 버튼을 누르면 로그인을 하도록 유도하기 위해 JavaScript를 이용해야함
- view.html에 CSRF 토큰이 처리되도록 의미 없는 태그를 하나 추가, 댓글 작성자는 현재 로그인한 사용자로 처리
- 로그인을 하지 않은 사용자는 로그인 페이지로 이동시키고, 로그인한 사용자는 사용자의 아이디가 댓글 입력창에 고정되도록 함 (댓글 작성자는 readonly로 함)
- 댓글을 저장할 때에는 댓글의 제목과 작성자 정보 외에도 CSRF 파라미터를 같이 전달해야 함
- JavaScript에서 CSRF 값을 이용하기 위해서 '${_csrf}' 객체를 JavaScript의 객체로 변환할 필요가 있음 (Thymeleaf의 인라인 기능을 이용하면 이를 쉽게 처리할 수 있음)
- Thymeleaf의 인라인 JavaScript는 객체를 JavaScript의 객체 문법으로 변환해 줌

* view.html에 CSRF 토큰에 대한 의미 없는 태그를 추가한 이유
- 시큐리티 설정이 필요한 페이지에서 사용할 때 서버에서 illegalState Exception 메세지가 출력되는 경우가 있음, 이런 상황에서는 브라우저에서 JavaScript 객체가 제대로 생성이 되지 않기 때문
- 이러한 메세지가 출력되는 이유는 CSRF 토큰이 만들어지기 전에 사용하면서 발생, 이를 해결하는 가장 간단한 방법은 th:action 처럼 의미 없는 <form> 태그를 추가
- Thymeleaf의 th:action을 처리하기 위해서는 반드시 CSRF 값을 생성해 내기 때문에 이와 같은 상황에서 유용

- JSON.parse()를 이용했기 때문에 문자열을 JavaScript의 객체로 만들어주고, Ajax호출 시 필요한 데이터를 추가할 수 있음
- 댓글 추가 버튼을 누르면 JavaScript 객체로 만들어진 csrf 객체를 같이 전송, 실제로 Ajax를 전송하는 reply.js에서는 전달된 csrf 객체를 처리
- 가장 중요한 부분은 Ajax 전송 시 'X-CSRF-TOKEN' 헤더를 지정해 주는 것, csrf 객체에서 headerName과 token 값을 이용해 Http 헤더 정보를 구성
- 이 코드를 이용해서 실제로 댓글을 추가하면 브라우저는 서버에 'X-CSRF-TOKEN' 헤더를 추가한 상태에서 전송하게 됨
[console]
csrf:
headerName: "X-CSRF-TOKEN"
parameterName: "_csrf"
token: "5116b495-c83f-43a5-9295-7aba2034c429"
=> 화면에서는 정상적으로 댓글이 추가되는 것을 확인할 수 있음

9.5.2. 댓글 수정/삭제
- 댓글의 수정과 삭제는 현재 로그인한 사용자가 작성한 댓글만 가능하므로, 홤ㄴ에서 버튼을 제어할 필요가 있음
- 화면에서 댓글을 조회하는 건 자유롭지만, 자신이 작성하지 않은 댓글을 수정하거나 삭제하는 작업은 제한되도록 버튼 자체가 보이지 않게 됨
- 댓글의 수정과 삭제 역시 CSRF 값을 같이 사용해야 하므로 reply.js를 호출하기 전 csrf 객체를 전달하도록 수정, 댓글 수정/삭제 작업을 처리하는 reply.js에서도 csrf를 적용
- 수정 후 정상적으로 동작하는지 테스트

9.6. 기타 설정 - 로그인 후 페이지 이동
- 시큐리티를 이용하면서 한 번쯤 고민하는 내용 중 하나는 로그인이 필요하지 않은 페이지에서 특정한 작업을 하기 위해 로그인을 하는 경우의 처리임
- 만일 로그인이 필요한 URL이었다면 이미 로그인 페이지를 거치기 때문에 문제가 없지만, 페이지 내에서 로그인이 필요한 경우 조금 다른 접근이 필요
- 예를 들어, '게시물의 조회' 에서는 별도 로그인이 필요하지 않았지만, '조회 페이지 내에서 댓글을 추가' 하는 등의 작업을 하는 경우에는 로그인이 필요
- 이와 같은 경우를 처리하려면, 로그인을 호출하는 페이지의 정보를 저장했다가 로그인이 성공한 후 특정한 URL로 이동하도록 처리할 필요가 있음 (스프링 MVC의 인터셉터와 Spring Security의 AuthenticationSuccessHandler를 이용)
- 지금까지 작성된 코드는 사용자가 '/boards/view?'를 호출하는 경우에는 로그인을 체크하지 않고 사용할 수 있는 상태, 이후 댓글을 추가하고 싶다면 로그인 페이지로 이동, 로그인 성공 후에는 '/' 경로로 이동하게 됨
- 원하는 작업은 로그인 후 다시 '/boards/view?...'로 이동하는 것
* 구현 방식
1) '/login' 경로를 호출할 때 특정 파라미터 (dist)를 추가하고, 파라미터의 값으로 로그인 후에 이동할 경로를 지정
2) '/login' 의 호출을 감지하는 인터셉터를 호출 추가해 호출 시 파라미터가 존재하는지 확인하고, 만일 존재한다면 HttpSession에 값을 추가해 둠
3) 로그인이 성공한 후 HttpSession에 특정한 값이 보관되어 있었다면 이를 이용해 redirect

9.6.1. 인터셉터 추가
- 인터셉터는 컨트롤러의 호출을 사전 혹은 사후에 가로챌 수 있고, 컨트롤러가 HttpServlet Request나 HttpServlet Response를 이용하지 않는 데 비해 인터셉터는 서블릿 관련 자원들을 그대로 활용할 수 있다는 장점이 있음
- interceptor 패키지를 작성하고 LoginCheckInterceptor 클래스를 생성
- 스프링의 인터셉터에 여러 메소드 중 preHandle()은 컨트롤러의 호출 전 동작, 코드의 내용은 파라미터의 이름에 dest가 존재한다면 이를 HttpSession에 저장하게 됨






























