#7. REST 방식의 댓글 처리와 JPA 처리

- JavaScript와 Ajax를 이용한 댓글 관련 기능 추가 
1) 게시물의 리스트 화면에서 댓글의 개수 구현
2) 게시물의 조회 화면에서 댓글 목록 출력
3) 댓글과 관련된 모든 기능이 특정한 게시물의 조회 화면에서 이루어지도록 구현
- 댓글과 관련된 기능 개발은 컨트롤러의 경우 @RestController를 적용하여 데이터와 GET/POST/PUT/DELETE 와 같은 전송 방식 이용, 화면은 Ajax를 이용해 처리

7.1. 프로젝트의 구성과 @RestControler
- 댓글 처리는 하나의 화면에서 이루어짐, 조회 화면이라는 한 페이지 안에서 댓글의 목록이 보이고, 새로운 댓글이 추가, 수정, 삭제됨
- 댓글 개발 작업은 화면의 이동이 없는 상태에서 데이터를 주고 받는 Ajax나 WebSocket, Socket.io 등의 방식을 이용하는 것이 좋음 (Ajax, @RestController를 이용)

7.1.1. REST 방식과 @RestController
- HTTP 프로토콜에서 데이터를 전송하는 방식의 구분
1) GET 방식 데이터를 보여주거나 다른 사람들에게 알리는 방식 : 기본적으로는 정보의 확산을 목적으로 설계, 인터넷상의 URL은 하나의 고유한 데이터를 찾는 이름이나 태그가 됨
2) POST 방식 데이터를 이용해서 특별한 작업을 처리하는 방식 : 정보의 가공이 목적, 정확한 목적을 가지고 특정한 작업을 수행하기 위해 사용
- WEB이 세상에 알려지면서 사실상 모든 작업은 정보 자체를 보거나(get), 정보를 이용한 특정한 작업을 하는 것(post)으로 구분
- GET 방식은 모든 상세한 정보를 URL에 '?' 로 연결하고 다른 사용자들 역시 정보들을 볼 수 있게 함
- POST 방식은 특정한 URL에 추가적인 정보를 전달하면서 원하는 작업을 진행하게 됨
- REST 방식이란, GET/POST 방식을 이용하던 시대를 지나오면서 작업을 할 때 좀 더 범용적인 규칙을 갖고자 하는 움직임임
- 인터넷의 URL이란 '하나의 온전한 자원의 상징' 임, 이 말은 하나의 URL은 지구상에 유일한, 특정한 콘텐츠의 고유한 값이어야 한다는 것
- 쇼핑몰을 예로 들자면 과거에는 특정 상품을 조회할 때 '/product.do?pno=12345' 와 같은 방식을 이용해서 '기능' 자체가 URL이 되고, 파라미터 등을 이용해 데이터를 제공하는 형태를 사용해 왔음
- 반면 최근에는 REST 방식을 이용해 URL이라는 것이 하나의 온전한 콘텐츠 자체를 의미하기 때문에 'product/12345'를 웹상에서 유일한 컨텐츠의 아이디처럼 사용하는 것을 권장
- REST 방식에서는 URL이 콘텐츠 자체를 의미하기 때문에 컨텐츠에 대한 어떤 작업을 할 것인가는 GET/POST/PUT/DELETE 등 전송 방식(method)를 이용해 처리
1) GET : 특정 리소스를 조회(read) 하는 용도로 사용, ex) /products/123
2) POST : 특정 리소스를 생성(create) 하는 용도로 사용, ex) /products/ 혹은 /member/123
3) PUT : 특정 리소스를 수정
4) DELETE : 특정 리소스를 삭제
- REST 방식으로 설계하는 경우에는 '명사'가 URL 구분이 되고, '동사'가 전송 방식이 됨, 각 단계는 '/'를 이용해서 구분 처리하고, 마지막에는 가장 상세한 정보 (번호나 아이디 등)를 사용
- REST 방식의 설계를 위해 사용하는 어노테이션
1) @RequestBody : 클라이언트가 보내는 JSON 데이터의 수집 및 가공
2) @ResponseBody : 클라이언트에게 전송되는 데이터에 맞게 MIME 타입을 결정
3) @PathVariable : URL의 경로에 포함된 정보 추출
4) @RestController : 컨트롤러의 모든 메소드 리턴 타입으로 @ResponseBody를 기본으로 지정
- 과거에는 REST 방식으로 데이터를 처리하려면 여러 개의 라이브러리와 복잡한 설정이 필요했지만, 최근에는 Web 관련 처리에 모두 포함되어서 필요한 경우에만 개발 내용을 추가

7.2. JPA의 설계와 Repository의 설계/테스트
- 게시글과 댓글의 관계는 '일대다', '다대일'이라고 볼 수 있음, 연관관계를 설정하기 위해 단방향인지 양방향인지 결정해야 하는데, '양방향'으로 설계 (domain 패키지에 WebReply 클래스 추가)

7.2.1. 연관관계의 설정
- WebBoard와 WebReply는 양방향의 관계로 설정할 것이므로, WebReply에는 WebBoard를 @ManyToOne 관계로 설정하고, WebBoard에는 @OneToMany 관계를 설정 (@ToString 부분에 exclude를 이용)
- 불필요하게 양쪽 테이블을 조회하지 않도록 양쪽 모두 '지연 로딩'방식으로 설정
- 연관 관계가 설정되었다면 테이블이 원하는 구조로 생성되는지 확인할 수 있도록 프로젝트의 main() 실행
[log]
Hibernate: create table tbl_webreplies (rno bigint not null auto_increment, regdate datetime, reply_text varchar(255), replyer varchar(255), updatedate datetime, board_bno bigint, primary key (rno)) engine=InnoDB
Hibernate: alter table tbl_webreplies add constraint FKoqessctbkmr17s2vyoy825r2s foreign key (board_bno) references tbl_webboards (bno)

* @Jsonlgnore 어노테이션
- REST 방식에서는 데이터를 전송하거나 반환할 때 JSON 형태의 데이터를 주고 받도록 설계
- Spring MVC는 객체의 데이터를 자동으로 JSON 데이터 처리해 주는 'jackson-databind'를 이용해 JSON 변환을 처리 (스프링부트일 경우 자동으로 다운로드)
- JSON 변환은 현재 객체를 JSON으로 반환하는 것 외에도 객체가 참조하고 있는 내부 객체 역시 JSON으로 변환
- 문제는 양방향일 경우 이러한 변환이 상호 호출되기 때문에 무한히 반복해서 생성하는 문제가 생길 수 있음 (Lombok의 toStirng()이 상호 호출되는 것과 동일한 문제)
- 이를 해결하기 위해 특정한 속성은 JSON으로 변환되지 않도록 @JsonIgnore 어노테이션 적용
- @JsonIgnore는 객체를 JSON 형태로 만들 때 제외시켜주기 때문에 최종적으로 WebReply 객체를 변환한 JSON 데이터에서는 WebBoard와 관련된 내용은 제외됨

7.2.2. ReplyRepository 추가
- WebReply는 단독으로 CRUD 작업이 가능하기 때문에 별도의 Repository를 생성하는 것이 좋음 (댓글 내용은 특별히 검색 처리를 하지 않을 것이므로, QuerydslPredicateExcuter를 추가하지 않음)

7.2.3. WebReplyRepository 테스트
- 더미 데이터를 추가하는 테스트 코드 작성, Test 폴더에 Test 클래스 작성
- testInsertReplies()의 내용은 지정된 게시물의 번호를 이용해 댓글을 10개씩 추가

7.3. ReplyController의 설계
- 댓글은 REST 방식으로 처리하기로 결정했다면, 가장 중요한 결정은 '각 작업을 위한 URL의 설계', REST방식에서 자원은 보통 복수형을 사용하므로 '/replis'를 이용하는 형태로 시작
1) 댓글 추가 - POST - /replis/게시물 번호
2) 댓글 삭제 - DELETE - /replis/게시물 번호/댓글 번호
3) 댓글 수정 - PUT - /replis/게시물 번호
4) 모든 댓글- GET - /replis/게시물 번호
- URI를 어떤 방식으로 만들 것인지 결정했다면 해당 방식으로 URL이 제대로 동작하는지 확인해야함, 컨트롤러 추가 (@RestController 어노테이션 추가, WebReplyRepository 주입)

7.3.1. 특정 게시물의 댓글 등록 처리
- 화면상에서의 댓글 등록 처리는 Ajax를 이용, 이를 위해 전달되는 데이터를 JSON 형태로 처리
- 이 작업을 위해 @PathVariable과 @RequestBody 어노테이션 활용
- @PathVariable은 URI의 일부를 파라미터로 받기 위해 사용하는 어노테이션, @RequestBody는 JSON으로 전달되는 데이터를 객체로 자동으로 변환하도록 처리하는 역할
- 컨트롤러의 메소드들의 리턴 타입은 특이하게 ResponseEntity 타입을 이용
- ReponseEntity는 코드를 이용해 직접 Http Response의 상태 코드와 데이터를 직접 제어해서 처리할 수 있는 장점이 있음
- addReply()에서는 우선적으로 HTTP의 상태 코드 중에 201을 의미하는 'created'라는 메시지를 전송하도록 함, 작성된 메소드에 대한 테스트는 REST 방식을 호출하는 프로그램을 이용하는 것이 편리







