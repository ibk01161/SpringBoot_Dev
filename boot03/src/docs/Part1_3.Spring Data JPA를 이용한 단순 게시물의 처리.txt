#3. Spring Data JPA를 이용한 단순 게시물의 처리 (boot03)

* 쿼리 연습을 위한 준비
- JPA에서는 각 데이터베이스에 맞는 Dialect가 별도의 SQL에 대한 처리를 자동으로 처리해 주기 때문에 개발 시 생산성을 향상시킬 수 있음
- 반면 조금 복잡한 쿼리를 작성하기 위해서는 데이터베이스를 대상으로 하는 SQL이 아니라 JPA에서 사용하는 Named Query나 JPQL(Java Persistence Query Language), Query dsl 이라는 것을 학습해야 함
- 쿼리 메소드는 메소드의 이름만으로 필요한 쿼리를 만들어 내는 기능으로, 별도의 학습 없이 몇 가지 네이밍 룰만 알고 있어도 사용 가능
- 새 프로젝트 만들고 필요한 더미 테이터 생성

1) 쿼리 메소드 이용하기
- Spring Data JPA는 메소드의 이름만으로 원하는 질의(Query)를 실행할 수 있는 방법을 제공, 이때 쿼리라는 용어는 'select'에만 해당 (find..By.., read..By.., query..By.., get..By.., count..By..)
- 예를 들어 'find..By..'로 쿼리 메소드를 작성한다면 'find' 뒤에 엔티티 타입을 지정, Boar 클래스라면 'findBoardBy...' 가 됨, 만약 중간에 엔티티타입을 지정하지 않으면 현재 실행하는 Repository의 타입 정보를 기준으로 동작하게 됨
- 'By' 뒤쪽은 칼럼명을 이용해 구성, 예를 들어 제목으로 검색하고자 한다면 'findBoardByTitle'이 됨
- 쿼리 메소드의 리턴 타입은 Page<T>, Slice<T>, List<T>와 같은 Collection<T> 형태가 될 수 있는데 가장 많이 사용되는 것은 List<T>, Page<T> 타입임
- 쿼리 메소드를 생성하고 실행시켜 보면 콘솔에 'from tbl_boards board0_ where board0_.title=?' 와 같은 형태로 작성되는 것을 확인
[log]
Hibernate: select board0_.bno as bno1_0_, board0_.content as content2_0_, board0_.regdate as regdate3_0_, board0_.title as title4_0_, board0_.updatedate as updateda5_0_, board0_.writer as writer6_0_ from tbl_boards board0_ where board0_.title=?
Board(bno=177, title=제목..177, writer=user07, content=내용..177, regdate=2020-08-23 15:56:44.0, updatedate=2020-08-23 15:56:44.0)

* findBy를 이용한 특정 컬럼 처리
- SQL문에서 특정한 컬럼의 값을 조회할 때는 쿼리 메소드의 이름을 findBy로 시작하는 방식을 이용 => Collection<T> findBy + 속성 이름(속성 타입)
- 예를 들어 '게시물에서 user00이라는 작성자의 모든 데이터를 구한다.' 라는 기능을 BoardRepository에 추가한다면 => Collection<Board> findByWriter(String writer)
- findBy... 로 시작하는 쿼리 메소드는 지정하는 속성의 값에 따라 파라미터의 타입이 결정, Board 클래스에서 writer속성의 값이 문자열이기 때문에 파라미터 타입은 String으로 지정
- findBy... 로 시작하는 쿼리 메소드의 리턴 타입은 Collection으로 설계하면 되기 때문에 forEach구문 이용해서 데이터 출력
- 테스트 코드를 실행하면 where문 뒤에 writer 칼럼을 검색하는 코드가 출력 (from tbl_boards board0_ where board0_.writer=?)
[log]
Hibernate: select board0_.bno as bno1_0_, board0_.content as content2_0_, board0_.regdate as regdate3_0_, board0_.title as title4_0_, board0_.updatedate as updateda5_0_, board0_.writer as writer6_0_ from tbl_boards board0_ where board0_.writer=?
Board(bno=10, title=제목..10, writer=user00, content=내용..10, regdate=2020-08-23 15:56:43.0, updatedate=2020-08-23 15:56:43.0)
Board(bno=20, title=제목..20, writer=user00, content=내용..20, regdate=2020-08-23 15:56:43.0, updatedate=2020-08-23 15:56:43.0)
....

* like 구문 처리 (쿼리 메소드)
- findBy와 더불어 가장 많이 사용하는 구문
- like에 대한 처리는 단순한 like, 키워드 + '%', '%' + 키워드, '%' + 키워드 + '%' 와 같은 4가지 형태 사용
1) 단순 like => Like
2) 키워드 + '%' => StartingWith
3) '%' + 키워드 => EndingWith
4) '%' + 키워드 + '%' => Containing
[log]
Hibernate: select board0_.bno as bno1_0_, board0_.content as content2_0_, board0_.regdate as regdate3_0_, board0_.title as title4_0_, board0_.updatedate as updateda5_0_, board0_.writer as writer6_0_ from tbl_boards board0_ where board0_.writer like ? escape ?
Board(bno=5, title=제목..5, writer=user05, content=내용..5, regdate=2020-08-23 15:56:43.0, updatedate=2020-08-23 15:56:43.0)
Board(bno=15, title=제목..15, writer=user05, content=내용..15, regdate=2020-08-23 15:56:43.0, updatedate=2020-08-23 15:56:43.0)
....

* and 혹은 or 조건처리
- 경우에 따라 2개 이상의 속성을 이용해서 엔티티를 검색해야 할 때는 'And'와 'Or'을 사용, 속성이 두 개 이상일 때는 파라미터 역시 지정한 속성의 수 만큼 맞춰줘야 함
- 예를 들어, 게시글의 title과 content속성에 특정한 문자열이 들어있는 게시물을 검색하려면 => 'findBy' + 'TitleContaining' + 'Or' + 'ContentContaining'과 같은 형태가 됨

* 부등호 처리
- 쿼리 메소드에서는 '>' 와 '<' 같은 부등호는 'GreaterThan' 와 LessThan'을 이용해 처리
- 예를 들어, 게시물의 title에 특정한 문자가 포함되어 있고, bno가 특정 숫자 초과인 데이터 조회 => Collection<Board> findByTitleContainingAndBnoGreaterThan
- 테스트를 실행하면 SQL 상에서 '>'가 만들어짐 (from tbl_boards board0_ where (board0_.title like ? escape ?) and board0_.bno>?)
[log]
Hibernate: select board0_.bno as bno1_0_, board0_.content as content2_0_, board0_.regdate as regdate3_0_, board0_.title as title4_0_, board0_.updatedate as updateda5_0_, board0_.writer as writer6_0_ from tbl_boards board0_ where (board0_.title like ? escape ?) and board0_.bno>?
Board(bno=105, title=제목..105, writer=user05, content=내용..105, regdate=2020-08-23 15:56:44.0, updatedate=2020-08-23 15:56:44.0)
Board(bno=115, title=제목..115, writer=user05, content=내용..115, regdate=2020-08-23 15:56:44.0, updatedate=2020-08-23 15:56:44.0)
...

* order by 처리
- 가져오는 데이터의 순서를 지정하기 위해서 'OrderBy' + 속성 + 'Asc or Desc'를 이용해서 작성
- 예를 들어, 게시물의 bno가 특정 번호보다 큰 게시물을 bno 값의 역순으로 처리하고 싶으면 => Collection<Board> findByBnoGreaterThanOrderByBnoDesc(Long bno)
- 테스트를 실행하면 SQL 상에서 order by 적용 (from tbl_boards board0_ where board0_.bno>? order by board0_.bno desc) 
[log]
Hibernate: select board0_.bno as bno1_0_, board0_.content as content2_0_, board0_.regdate as regdate3_0_, board0_.title as title4_0_, board0_.updatedate as updateda5_0_, board0_.writer as writer6_0_ from tbl_boards board0_ where board0_.bno>? order by board0_.bno desc
Board(bno=200, title=제목..200, writer=user00, content=내용..200, regdate=2020-08-23 15:56:44.0, updatedate=2020-08-23 15:56:44.0)
Board(bno=199, title=제목..199, writer=user09, content=내용..199, regdate=2020-08-23 15:56:44.0, updatedate=2020-08-23 15:56:44.0)
...

* 페이징 처리와 정렬
- 쿼리 메소드들에는 특이하게 모든 쿼리 메소드의 마지막 파라미터로 페이지 처리를 할 수 있는 Pageable 인터페이스와 정렬을 처리하는 Sort 인터페이스를 사용할 수 있음
- Pageable 인터페이스는 말 그대로 페이징 처리에 필요한 정보를 제공, 보통 가장 많이 사용하는 것은 Pageable 인터페이스를 구현한 클래스 중 PageRequest 클래스를 이용
- 예를 들어, bno가 0보다 크고, 내림차순 => List<Board> findByBnoGreaterThanOrderByBnoDesc(Long bno, Pageable paging)
- 기존 코드와 차이점은 파라미터에 Pageable이 적용되어 있고, 리턴 타입으로 List<> 적용, Pageable 인터페이스가 적용된 경우, 리턴 타입은 Slice 타입, Page 타입, List 타입을 사용해야 함
- 테스트 시 Pageable 인터페이스에는 여러 메소드가 존재하기 때문에 이를 구현하는 대신 PageRequest 클래스를 이용한는 것이 편리(여러 종류의 생성자 지원)
- 그 중 가장 간단한 방법은 페이지 번호와 페이지당 데이터의 수를 지정하는 방식(PageRequest.of(0,10)은 첫 번째 페이지 이고 10건의 데이터를 가져오도록 설정)
- 테스트를 실행하면 SQL 상에서 MySQL이기 때문에 자동으로 limit가 적용 (from tbl_boards board0_ where board0_.bno>? order by board0_.bno desc limit ?)
[log]
Hibernate: select board0_.bno as bno1_0_, board0_.content as content2_0_, board0_.regdate as regdate3_0_, board0_.title as title4_0_, board0_.updatedate as updateda5_0_, board0_.writer as writer6_0_ from tbl_boards board0_ where board0_.bno>? order by board0_.bno desc limit ?
Board(bno=200, title=제목..200, writer=user00, content=내용..200, regdate=2020-08-23 15:56:44.0, updatedate=2020-08-23 15:56:44.0)
Board(bno=199, title=제목..199, writer=user09, content=내용..199, regdate=2020-08-23 15:56:44.0, updatedate=2020-08-23 15:56:44.0)
...

- 정렬 처리에는 Pageable 인터페이스와 같이 Sort 클래스 이용, Sort는 쿼리 메소드에서 OrderBy로 처리해도 되지만, Sort를 이용하면 원하는 방향을 파라미터로 결정할 수 있다는 장점이 있음
** PageRequest의 of() 기능
1) PageRequest.of(int page, int size) - 페이지 번호(0부터 시작), 페이지당 데이터의 수
2) PageRequest.of(int page, int size, Sort.Direction direction, String... props) - 페이지 번호, 페이지당 데이터 수, 정렬 방향, 속성(칼럼) 들
3) pageRequest.of(int page, int size, Sort sort) - 페이지 번호, 페이지당 데이터 수, 정렬 방향
- PageRequest의 생성자 중에 Sort 인터페이스 타입을 파라미터로 전달할 수 있는 생성자가 있는데, 이를 이용하면 페이징 처리와 정렬에 대한 처리를 동시에 지정할 수 있음
- 쿼리 메소드에서 OrderBy 부분 없이 Pageable만 파라미터로 처리 => List<Board> findByBnoGreaterThan(Long bno, Pageable paging)
- 테스트 시 메소드의 이름에서 정렬과 관련된 조건이 빠진 것은 PageRequest()를 이용해 처리 가능 (where board0_.bno>? order by board0_.bno asc limit ?)
[log]
Hibernate: select board0_.bno as bno1_0_, board0_.content as content2_0_, board0_.regdate as regdate3_0_, board0_.title as title4_0_, board0_.updatedate as updateda5_0_, board0_.writer as writer6_0_ from tbl_boards board0_ where board0_.bno>? order by board0_.bno asc limit ?
Board(bno=1, title=제목..1, writer=user01, content=내용..1, regdate=2020-08-23 15:56:43.0, updatedate=2020-08-23 15:56:43.0)
Board(bno=2, title=제목..2, writer=user02, content=내용..2, regdate=2020-08-23 15:56:43.0, updatedate=2020-08-23 15:56:43.0)
...

* Page<T> 타입
- Spring Data JPA 에서 결과 데이터가 여러개인 경우 List<T> 타입을 이용하기도 하지만, Page<T>타입을 이용하면 Spring MVC와 연동할 때 편리함
- Page<T>는 단순 데이터만 추출하는 용도가 아니라, 흔히 웹에서 필요한 데이터들을 추가적으로 처리해 줌
- 테스트 코드를 실행하면 실제로 SQL문이 두 번 실행됨, 처음에는 데이터를 추출하기 위해 실행 (select), 두 번째는 데이터 개수 파악 (select count...)하기 위해 실행
- 리턴 타입을 Page<T>로 하게 되면 웹 페이징에서 필요한 데이터를 한 번에 처리할 수 있기 때문에 데이터를 위한 SQL과 개수를 파악하기 위한 SQL을 매번 작성하는 불편함 사라짐
[log]
Hibernate: select board0_.bno as bno1_0_, board0_.content as content2_0_, board0_.regdate as regdate3_0_, board0_.title as title4_0_, board0_.updatedate as updateda5_0_, board0_.writer as writer6_0_ from tbl_boards board0_ where board0_.bno>? order by board0_.bno asc limit ?
Hibernate: select count(board0_.bno) as col_0_0_ from tbl_boards board0_ where board0_.bno>?
PAGE SIZE : 10
TOTAL SIZE : 20
TOTAL COUNT : 200
NEXT : Page request [number: 1, size 10, sort: bno: ASC]
Board(bno=1, title=제목..1, writer=user01, content=내용..1, regdate=2020-08-23 15:56:43.0, updatedate=2020-08-23 15:56:43.0)
Board(bno=2, title=제목..2, writer=user02, content=내용..2, regdate=2020-08-23 15:56:43.0, updatedate=2020-08-23 15:56:43.0)
....