#8. Spring Web Security

- 웹 기반 프로젝트에서 사용자 인증을 처리하는 부분은 반드시 필요한 부분임, 스프링의 경우 이러한 작업을 위해 Spring Security를 적용할 수 있음
- 스프링 시큐리티 적용
1) 사용자의 권한에 따른 URI 접근 제어
2) 데이터베이스와 연동하는 로그인 처리
3) 쿠키를 이용한 자동 로그인 (remember-me)
4) 패스워드 암호화

* 인증(Authentication)과 인가(Authorization) 이란?
- 인증 : '증명하다' 라는 의미, 이때 증명의 대상은 어떤 경우에는 표시나 자격일 수도 있고, 사람의 신분일 수도 있음, 예를들어 만일 우리가 암호가 걸려있는 시스템을 사용한다면, 인증 절차를 거쳐야함
          'Pass(지나가다)' 라는 개념과 관련이 있음, 예를 들어 집에 들어가기 전 입력하는 암호 또는 열쇠로 문을 여는 행위가 '인증' 이라고 볼 수 있음, 실제 인증은 보통 자물쇠와 같은 이미지로 표현됨
- 인가 : '권한 부여' 나 '허가'와 같은 의미로 사용, 보안에서는 어떤 대상이 있다면 인가된 사용자만이 보안된 대상을 사용할 수 있다는 의미로 해석

=> 웹에서 '인증' 이란 해당 URL은 보안 절차를 거친 사용자들만이 접근할 수 있다는 의미, '인가' 란 URL에 접근한 사용자가 특정한 자격이 있다는 것을 의미

8.1. 예제 프로젝트 생성
1) 사용자와 사용자의 권한을 관리하는 기능
2) 해당 기능을 이용해 스프링 시큐리티를 적용하는 부분
- 이전 장에서 사용했던 라이브러리들과 더불어, 'security' 항목의 'Spring Security' 추가해 생성, application.properties 수정 (마지막에 security 관련 로그 출력하는 부분에 대한 설정을 'debug'로 설정)

8.1.1. 시큐리티의 기본 설정 추가하기
- 프로젝트에는 스프링 시큐리티가 추가될 것이므로, 시큐리티에 대한 설정 필요, 이를 위해 security 패키지에 클래스 추가
- 생성한 SecurityConfig는 아무런 어노테이션이 적용되지 않은 상태이기 때문에, 스프링의 빈(Bean)으로 인식되지 않음
- 작성된 SecurityConfig가 정상적으로 인식되도록 @EnableWebSecurity 어노테이션을 추가하고, 설정을 담당하는 WebSecurityConfigurerAdapter 클래스를 상속
- 작성된 SecurityConfig 클래스에는 WebSecurityConfigurerAdapter 클래스의 여러 메소드 중 configure() 메소드를 오버라이드해서 간단한 로그 메세지를 출력하도록 작성
- configure() 메소드를 오버라이드하는 경우에는 HttpSecurity 클래스 타입을 파라미터로 처리하는 메소드를 선택한다는 점에 주의
- 어노테이션을 추가한 뒤 SecurityConfig가 스프링의 빈으로 등록되었는지 확인하고, 프로젝트를 실행해 log.info() 부분이 적용되는지 확인 (아무 문제가 없다면 스프링 시큐리티에서 자동으로 생성한 패스워드와 로그가 출력되는 것을 확인O)
[log]
Using generated security password: a5200a1b-e246-4b7c-8273-809b8296aa2d
2020-10-05 23:25:02.574  INFO 19432 --- [  restartedMain] org.zerock.security.SecurityConfig       : security config................
- 스프링 시큐리티는 기본적으로 하나의 사용자 정보를 가지도록 기본 세팅되어 있음, 사용자 이름은 'user', 패스워드는 로그에서 출력되는 정보임
- 만약 SecurityConfig를 생성하지 않고, 컨트롤러와 Thymeleaf를 이용하는 페이지를 제작했다면 스프링 시큐리티는 모든 URI에 대한 인증을 요구
- 이런 경우에는 사용자 이름을 'user'로 지정하고, 서버 실행 시 생성된 패스워드를 입력해 주면 정상적으로 처리, SecurityConfig를 생성하고 config()를 작성했다면 이와 같은 기본 설정은 더 이상 사용하지 않음

8.1.2. 샘플 URI 생성
- 스프링 시큐리티가 정상적으로 사용 가능하다는 것을 확인했다면, 웹상에 시큐리티를 적용하기 위한 컨트롤러와 화면들을 생성해야함 (controller 패키지 생성 후 컨트롤러 생성)
- SampleController는 우선 단순히 몇 개의 페이지를 생성하고 나중에 시큐리티를 적용해서 접근을 제어하는 용도로 사용
- 정상적으로 예제가 동작하기 위해서는 templates에 해당 파일들을 생성, 화면자체는 스프링 시큐리티가 제대로 적용되고 있는지를 확인하는 용도로 사용하는 것이므로 단순한 형태로 작성

8.2. 회원과 권한 설계
- 스프링 시큐리티를 적용하기 위해 실제와 비슷하게 데이터베이스를 이용, 이를 위해 Spring Data JPA를 이용해 서비스를 이용하는 회원과 각 회원이 가지는 권한을 생성해 두도록 함
- 회원에 대한 용어(클래스)는 Member를 이용, 일반적으로 User라는 용어를 사용하는 경우가 흔하지만, User라는 타입은 이미 스프링 시큐리티에서 이용하고 있기 때문에, 혼란을 피하기 위해 Member라는 이름 사용
- 회원(Member)은 등급이나 권한을 가지도록 설계, 실제 서비스에서는 Access Control List(접근 제한 목록 ACL) 라는 것을 작성해 특정 리소스나 작업에 대한 권한을 가진 사용자들만이 접근이나 수정 등 작업을 할 수 있도록 제어
- 프로젝트에서 작성하는 수준은 특정 회원(Member)이 특정한 권한(MemberRole)을 가진다고 가정하고, 특정 URL에 대해 이를 체크하도록 함

8.2.1. 도메인 클래스 설계
- 회원(Member)과 회원 권한(MemberRole)은 클래스로 설계되어야 하므로, domain 패키지에 엔티티 클래스 생성
- Member클래스는 회원의 아이디를 의미하는 uid와 upw, uname 등의 속성을 가지도록 설계 (스프링 시큐리티에서 username, password 등 용어를 사용하므로 가능하면 충돌이 나지 않도록 이름을 지정하는 것이 좋음)
- MemberRole 클래스는 회원이 가지는 권한에 대한 이름을 가지는 단순한 구조임

* 연관관계 설정
- 클래스를 작성했다면 해당 클래스 간의 연관관계를 지정해야 함
<상황정리>
1) Member와 MemberRole은 '일대다', '다대일'의 관계
2) MemberRole 자체가 단독으로 생성되는 경우는 거의 없으므로 Member가 MemberRole을 관리하는 방식의 설계
- MemberRole은 그 자체로는 별다른 의미를 가지지 못하기도 하고, Member에 대한 정보의 라이프사이클과 강하게 묶여 있기 때문에, Member가 MemberRole에 대한 참조를 가지도록 함
- 반면에 MemberRole은 정보에 대한 접근 방식 자체가 '회원'을 통한 접근이므로, 별도의 연관관계를 설정하지 않는 단방향 방식을 선택
- 프로젝트 실행하면 테이블이 생성된 것을 확인할 수 있음
[log]
Hibernate: create table tbl_member_roles (fno bigint not null auto_increment, role_name varchar(255), member varchar(255), primary key (fno)) engine=InnoDB
Hibernate: create table tbl_members (uid varchar(255) not null, regdate datetime, uname varchar(255), updatedate datetime, upw varchar(255), primary key (uid)) engine=InnoDB
Hibernate: alter table tbl_member_roles add constraint FKiy7scif7laghe23vht49x2aka foreign key (member) references tbl_members (uid)

8.2.2. Repository 생성
- Member가 핵심적인 역할을 하기 때문에 Repository 역시 persistence 패키지 생성하고, MemberRepository 작성

8.2.3. 테스트를 통한 데이터 추가/조회
- 테스트를 통해 테이블 간의 연관관계 설정을 좀 더 세밀하게 해 주는 것이 좋음, 테스트 폴더에 Test 클래스 생성
- 작성한 tests 클래스에 테스트에 사용할 데이터를 추가할 수 있도록 코드 추가
- 엔티티들의 영속관계를 한 번에 처리하지 못해서 에러가 발생해, 이에 대한 처리를 cascade 설정을 추가해야 함 (Member클래스)
- testInsert() 코드는 101명의 사용자를 생성, 사용자 중 user0 ~ 80 까지는 BASIC이라는 권한, user90까지는 MANAGER, 나머지 10명은 ADMIN 권한을 가지도록 설계
- 데이터베이스에 정상적으로 데이터가 추가되었으면, 회원 데이터와 함께 권한들에 대한 정보를 같이 조회할 수 있도록 조회 작업 진행
- tbl_members와 tble_members_roles 테이블을 둘 다 조회해야 하기 때문에 에러가 발생 => 즉시 로딩을 이용해 조인을 하는 방식으로 처리 (권한 정보는 회원 정보와 같이 필요한 경우가 많기 때문에, fetch 모드를 즉시 로딩으로 설정)
- testRead()를 실행하면 정상적으로 처리 확인
[log]
Hibernate: select member0_.uid as uid1_1_0_, member0_.regdate as regdate2_1_0_, member0_.uname as uname3_1_0_, member0_.updatedate as updateda4_1_0_, member0_.upw as upw5_1_0_, roles1_.member as member3_0_1_, roles1_.fno as fno1_0_1_, roles1_.fno as fno1_0_2_, roles1_.role_name as role_nam2_0_2_ from tbl_members member0_ left outer join tbl_member_roles roles1_ on member0_.uid=roles1_.member where member0_.uid=?
2020-10-07 23:33:08.388  INFO 12392 --- [           main] org.zerock.MemberTests                   : memberMember(uid=user85, upw=pw85, uname=사용자85, regdate=2020-10-07 23:27:00.0, updatedate=2020-10-07 23:27:00.0, roles=[MemberRole(fno=86, roleName=MANAGER)])

8.3. 단순 시큐리티 적용
- 스프링 시큐리티는 꽤 복잡하고 다양한 설정이 존재하기 때문에, 시큐리티를 학습할 때에는 단계별로 하나씩 과정을 진행해 보는 것이 좋음
- 웹에서의 스프링 시큐리티는 기본적으로 필터 기반으로 동작
- 스프링 시큐리티의 내부에는 상당히 많은 종류의 필터들이 이미 존재하고 있기 때문에, 개발 시에는 필터들의 설정을 조정하는 방식을 주로 사용

8.3.1. 로그인 / 로그아웃 관련 처리
- 가장 먼저 개발해 볼 내용은 로그인하지 않은 사용자가 특정 경로에 접근하는 것을 막고, 로그인과 로그아웃을 처리해 보는 것

1) 특정 권한을 가진 사람만이 특정 URI에 접근하기
- SecurityConfig 클래스에는 configure() 메소드를 이용해 웹 자원에 대한 보안을 확인, 현재까지의 configure()는 HttpSecurity 타입을 파라미터로 사용
- HttpSecurity는 웹과 관련된 다양한 보안 설정을 걸어줄 수 있음
- 특정한 경로에 특정한 권한을 가진 사용자만 접근할 수 있도록 설정하고 싶을 때에는 authorizeRequests()와 antMatches()를 이용해 경로를 설정할 수 있음
- authorizeRequests()는 시큐리티 처리에 HttpServletRequest를 이용한다는 것을 의미
- antMatches()에서는 특정 경로를 지정, 이후 permitAll()은 모든 사용자가 접근할 수 있다는 것을 의미, hasRole()은 시스템상에서 특정 권한을 가진 사람만이 접근할 수 있다는 것을 의미
- http.authorizeRequests() 뒤의 antMatches()는 사실 빌더 패턴으로, 예제에서는 가독성을 높이는 형태로 작성했으나 실제로는 연속적으로 '.(마침표)' 를 이용하는 방법을 더 많이 사용

* Role과 Privilege
- 사전적 의미에서 Role은 '역할' 이나 '자격'을 의미하고, Privilege는 '특권'을 의미
- 스프링 시큐리티에서는 Role 과 Peivilege 외에도 Authority라는 용어를 같이 사용하기 때문에 혼란스러울 수 있음
- Role은 일종의 Privilege들의 묶음, 세부적인 권한을 Privilege나 Authority로 보고, 이를 모아서 하나의 패키지나 템플릿으로 만든 것을 Role이라고 생각할 수 있음
- 이 책에서는 이에 대한 구분 없이 권한이라는 용어를 사용하지만 엄격히는 구분해서 사용하는 것이 정석

=> 변경된 설정이 제대로 적용되는지를 확인하기 위해 프로젝트를 실행하고, '/guest', '/manager' 경로로 접근
- 결과를 보면 '/manager'로 접근하는 경우 'Access Denied' 라는 메세지가 출력됨, 인가 받은 권한이 없기 때문에 해당 경로에 접근할 수 없도록 처리가 됨

2) 로그인 페이지 보여주기
- 인가 받은 권한이 없는 관계로 접근이 막혔다면 '/login'이라는 경로를 이용해 로그인 페이지를 띄워, 로그인을 해야 접근할 수 있다는 걸 인식시킬 필요가 있음
- configure()를 수정 => 마지막에 http.formLogin()이라는 경로를 작성, formLogin()은 form 태그 기반의 로그인을 지원하겠다는 설정, 별도 로그인 페이지를 제작하지 않아도 로그인 정보를 입력하는 페이지를 볼 수 있음
- 브라우저에서 '/login' 경로를 호출하면 스프링 시큐리티에서 제공하는 기본, 로그인 화면을 볼 수 있게 됨 (스프링 시큐리티가 기본으로 제공)

3) 로그인 정보 설정하기
- 화면에 로그인 페이지가 뜨기는 하지만, 어떤 값을 입력하여도 에러가 발생하면서 달라지는 내용은 없음
- 로그인이 되기 위해 SecurityConfig에 AuthenticationManagerBuilder를 주입해 인증에 대한 처리를 해야 함
- AuthenticationManagerBuilder는 단어 뜻 그대로 인증에 대한 다양한 설정을 생성할 수 있음
- 예를 들어, 메모리상에 있는 정보만을 이용한다거나, JDBC나 LDAP등 정보를 이용해 인증 처리가 가능 (예제에서는 메모리상 인증 정보를 활용)
- 설정 완료 후 '/manager'를 호출하면 사용자는 '/login'으로 이동, 로그인 처리가 제대로 되는지 확인하기 위해 아이디, 비밀번호 입력 후 로그인하면 '/manager'의 경로로 이동하고 정상적으로 페이지를 볼 수 있음

4) 로그인 관련 정보 삭제하기
- 웹과 관련된 로그인 정보는 기본적으로 HttpSession을 이용
- HttpSession은 세션 쿠키라는 것을 이용하기 때문에 기존 로그인 정보를 삭제해야 하는 상황에서는 브라우저를 완전히 종료하거나, 세션 쿠키를 삭제하는 방법을 이용 (크롬은 백그라운드에서 동작하는 경우가 있으므로 주의)
- 브라우저에서 기존에 접근한 웹 사이트의 모든 쿠키는 '개발자 도구 -> Application 탭 -> Cookies'를 통해 확인
- 'Cookie' 메뉴 아래 뜨는 사이트를 클릭하면 'Clear' 라는 창을 볼 수 있음, 'Clear'를 클릭하면 해당 사이트에서 받은 모든 쿠키를 삭제할 수 있음, 삭제된 후 다시 원하는 URL을 지정해서 호출할 수 있음
- 이와 같은 방식을 이용하면 매번 테스트 시에 브라우저를 종료하는 시간을 단축할 수 있다는 장점이 있음

5) 커스텀 로그인 페이지 만들기
- 스프링 시큐리티가 기본적으로 <form> 태그가 있는 웹 페이지를 만들어 주기는 하지만 좀 더 제대로 만들기 위해 사용자가 수정할 수 있는 웹 페이지를 만들어주는 것이 좋음
- 이를 위해 formLogin() 이후 loginPage() 메소드를 이용해 URI를 지정해 주면 됨, '/login' 이라는 URI는 더 이상 스프링 시큐리티가 아니기 때문에 직접 컨트롤러를 작성해야함 (login컨트롤러 추가, 화면은 login.html 추가)
- login.html은 크게 로그인에 문제가 생겼을 때 보여주는 부분과 <form> 태그를 이용해서 로그인 정보를 입력하는 부분으로 구성되어 있음
- 스프링 시큐리티는 기본적으로 username 과 password라는 이름을 이용하므로, <input> 태그의 name 속성값을 마음대로 변경할 수 없음
- <form> 태그의 action 속성을 지정하지 않았기 때문에 사용자가 버튼을 클릭하면 '/login'으로 이동하고 POST 방식으로 데이터를 전송하게 됨
- <form> 태그의 내부에는 hidden 속성으로 작성된 '_csrf' 라는 속성이 존재
- 이 속성은 '사이트 간 요청 위조(Cross-site request forgery, CSRF, XSRF)'를 방지하기 위한 것으로 요청을 보내는 URL에서 서버가 가진 동일한 값과 같은 값을 가지고 데이터를 전송할 때에만 신뢰하기 위한 방법
- 실제로 모든 작업은 여러 종류의 Filter 들과 Interceptor를 통해 동작하기 때문에 개발자 입장에서는 적절한 처리를 담당하는 핸들러(Handler)들을 추가하는 것만으로 모든 처리가 완료됨
- 스프링 시큐리티가 적용되면 POST방식으로 보내는 모든 데이터는 CSRF 토큰 값이 필요하다는 점을 명심 (application.properties에 security.enable-csrf 속성을 이용해 CSRF 토큰을 사용하지 않도록 설정할 수 있음)

6) 접근 권한 없음 페이지 처리
- 만일 사용자가 정상적으로 로그인을 하고 접근할 수 있는 권한을 가진 경로를 이용한다면 문제 없지만, 로그인 사용자라도 접근 권한이 없는 특정 경로로 접근하려 할 때는 여전히 'Access is Denied' 라는 메세지를 보게 됨
- '/admin' 으로 접근할 때 'ADMIN'이라는 권한이 있어야만 하는 설정 추가 => 브라우저에서 '/admin'경로로 접근하면 브라우저는 자동으로 '/login'경로로 이동
- 지정한 아이디와 패스워드 (manager/1111) 을 입력하고 로그인하면 여전히 'Access is denied' 라는 메세지를 보게 됨
- 이러한 경우에 사용자에게 권한 없음을 알려주고, 로그인 화면으로 이동할 수 있도록 안내 페이지를 작성할 필요가 있음, 이 설정은 HttpSecurity에서 exception Handling()을 이용해 지정
- exceptionHandling() 이후 메소드는 accessDeniedPage()나 accessDenidedHandler()를 이용하는 것이 일반적, '/accessDenied'라는 URI가 처리할 것이므로, LoginController에 메소드와 html 작성

7) 로그아웃 처리
지금까지 적상적으로 이용한 시나리오는
1) 사용자가 권한이 필요한 URI를 호출하면
2) 권한을 얻기 위해 로그인 페이지로 이동
3) 로그인 이후 원하는 화면을 볼 수 있음

- 스프링 시큐리티가 웹을 처리하는 방식의 기본은 HttpSession이므로 브라우저가 완전히 종료되면, 로그인한 정보를 잃게 됨 (HttpSession은 기본적으로 브라우저가 저장하지 않는 방식)
- 브라우저를 종료하지 않을 경우, 사용자 로그아웃을 행해서 자신이 로그인 했던 모든 정보를 삭제해야 함
- 이를 위해 HttpSession의 정보를 무효화시키고, 필요한 경우에는 모든 쿠키를 삭제해야 함
- logout() 뒤에는 invalidateHttpSession()과 deleteCookies()를 이용해 이러한 처리를 할 수 있음
- 로그아웃을 특정 페이지에서 진행하고 싶다면 먼저 로그아웃을 처리하는 URI를 처리해야 하고, POST 방식으로 로그아웃을 시도해야 함
- SecurityConfig의 configure()에서는 로그아웃을 위한 URI를 지정, http.logout().invalidateHttpSession(true)부분을 수정 후 logout.html 작성
- 로그아웃 처리가 된 후 다시 로그인이 필요한 RUI로 접근해 로그인을 요구하는지 확인

















