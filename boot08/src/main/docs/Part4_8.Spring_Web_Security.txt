#8. Spring Web Security

- 웹 기반 프로젝트에서 사용자 인증을 처리하는 부분은 반드시 필요한 부분임, 스프링의 경우 이러한 작업을 위해 Spring Security를 적용할 수 있음
- 스프링 시큐리티 적용
1) 사용자의 권한에 따른 URI 접근 제어
2) 데이터베이스와 연동하는 로그인 처리
3) 쿠키를 이용한 자동 로그인 (remember-me)
4) 패스워드 암호화

* 인증(Authentication)과 인가(Authorization) 이란?
- 인증 : '증명하다' 라는 의미, 이때 증명의 대상은 어떤 경우에는 표시나 자격일 수도 있고, 사람의 신분일 수도 있음, 예를들어 만일 우리가 암호가 걸려있는 시스템을 사용한다면, 인증 절차를 거쳐야함
          'Pass(지나가다)' 라는 개념과 관련이 있음, 예를 들어 집에 들어가기 전 입력하는 암호 또는 열쇠로 문을 여는 행위가 '인증' 이라고 볼 수 있음, 실제 인증은 보통 자물쇠와 같은 이미지로 표현됨
- 인가 : '권한 부여' 나 '허가'와 같은 의미로 사용, 보안에서는 어떤 대상이 있다면 인가된 사용자만이 보안된 대상을 사용할 수 있다는 의미로 해석

=> 웹에서 '인증' 이란 해당 URL은 보안 절차를 거친 사용자들만이 접근할 수 있다는 의미, '인가' 란 URL에 접근한 사용자가 특정한 자격이 있다는 것을 의미

8.1. 예제 프로젝트 생성
1) 사용자와 사용자의 권한을 관리하는 기능
2) 해당 기능을 이용해 스프링 시큐리티를 적용하는 부분
- 이전 장에서 사용했던 라이브러리들과 더불어, 'security' 항목의 'Spring Security' 추가해 생성, application.properties 수정 (마지막에 security 관련 로그 출력하는 부분에 대한 설정을 'debug'로 설정)

8.1.1. 시큐리티의 기본 설정 추가하기
- 프로젝트에는 스프링 시큐리티가 추가될 것이므로, 시큐리티에 대한 설정 필요, 이를 위해 security 패키지에 클래스 추가
- 생성한 SecurityConfig는 아무런 어노테이션이 적용되지 않은 상태이기 때문에, 스프링의 빈(Bean)으로 인식되지 않음
- 작성된 SecurityConfig가 정상적으로 인식되도록 @EnableWebSecurity 어노테이션을 추가하고, 설정을 담당하는 WebSecurityConfigurerAdapter 클래스를 상속
- 작성된 SecurityConfig 클래스에는 WebSecurityConfigurerAdapter 클래스의 여러 메소드 중 configure() 메소드를 오버라이드해서 간단한 로그 메세지를 출력하도록 작성
- configure() 메소드를 오버라이드하는 경우에는 HttpSecurity 클래스 타입을 파라미터로 처리하는 메소드를 선택한다는 점에 주의
- 어노테이션을 추가한 뒤 SecurityConfig가 스프링의 빈으로 등록되었는지 확인하고, 프로젝트를 실행해 log.info() 부분이 적용되는지 확인 (아무 문제가 없다면 스프링 시큐리티에서 자동으로 생성한 패스워드와 로그가 출력되는 것을 확인O)
[log]
Using generated security password: a5200a1b-e246-4b7c-8273-809b8296aa2d
2020-10-05 23:25:02.574  INFO 19432 --- [  restartedMain] org.zerock.security.SecurityConfig       : security config................
- 스프링 시큐리티는 기본적으로 하나의 사용자 정보를 가지도록 기본 세팅되어 있음, 사용자 이름은 'user', 패스워드는 로그에서 출력되는 정보임
- 만약 SecurityConfig를 생성하지 않고, 컨트롤러와 Thymeleaf를 이용하는 페이지를 제작했다면 스프링 시큐리티는 모든 URI에 대한 인증을 요구
- 이런 경우에는 사용자 이름을 'user'로 지정하고, 서버 실행 시 생성된 패스워드를 입력해 주면 정상적으로 처리, SecurityConfig를 생성하고 config()를 작성했다면 이와 같은 기본 설정은 더 이상 사용하지 않음

8.1.2. 샘플 URI 생성
- 스프링 시큐리티가 정상적으로 사용 가능하다는 것을 확인했다면, 웹상에 시큐리티를 적용하기 위한 컨트롤러와 화면들을 생성해야함 (controller 패키지 생성 후 컨트롤러 생성)
- SampleController는 우선 단순히 몇 개의 페이지를 생성하고 나중에 시큐리티를 적용해서 접근을 제어하는 용도로 사용
- 정상적으로 예제가 동작하기 위해서는 templates에 해당 파일들을 생성, 화면자체는 스프링 시큐리티가 제대로 적용되고 있는지를 확인하는 용도로 사용하는 것이므로 단순한 형태로 작성

8.2. 회원과 권한 설계
- 스프링 시큐리티를 적용하기 위해 실제와 비슷하게 데이터베이스를 이용, 이를 위해 Spring Data JPA를 이용해 서비스를 이용하는 회원과 각 회원이 가지는 권한을 생성해 두도록 함
- 회원에 대한 용어(클래스)는 Member를 이용, 일반적으로 User라는 용어를 사용하는 경우가 흔하지만, User라는 타입은 이미 스프링 시큐리티에서 이용하고 있기 때문에, 혼란을 피하기 위해 Member라는 이름 사용
- 회원(Member)은 등급이나 권한을 가지도록 설계, 실제 서비스에서는 Access Control List(접근 제한 목록 ACL) 라는 것을 작성해 특정 리소스나 작업에 대한 권한을 가진 사용자들만이 접근이나 수정 등 작업을 할 수 있도록 제어
- 프로젝트에서 작성하는 수준은 특정 회원(Member)이 특정한 권한(MemberRole)을 가진다고 가정하고, 특정 URL에 대해 이를 체크하도록 함

8.2.1. 도메인 클래스 설계
- 회원(Member)과 회원 권한(MemberRole)은 클래스로 설계되어야 하므로, domain 패키지에 엔티티 클래스 생성
- Member클래스는 회원의 아이디를 의미하는 uid와 upw, uname 등의 속성을 가지도록 설계 (스프링 시큐리티에서 username, password 등 용어를 사용하므로 가능하면 충돌이 나지 않도록 이름을 지정하는 것이 좋음)
- MemberRole 클래스는 회원이 가지는 권한에 대한 이름을 가지는 단순한 구조임

* 연관관계 설정
- 클래스를 작성했다면 해당 클래스 간의 연관관계를 지정해야 함
<상황정리>
1) Member와 MemberRole은 '일대다', '다대일'의 관계
2) MemberRole 자체가 단독으로 생성되는 경우는 거의 없으므로 Member가 MemberRole을 관리하는 방식의 설계
- MemberRole은 그 자체로는 별다른 의미를 가지지 못하기도 하고, Member에 대한 정보의 라이프사이클과 강하게 묶여 있기 때문에, Member가 MemberRole에 대한 참조를 가지도록 함
- 반면에 MemberRole은 정보에 대한 접근 방식 자체가 '회원'을 통한 접근이므로, 별도의 연관관계를 설정하지 않는 단방향 방식을 선택
- 프로젝트 실행하면 테이블이 생성된 것을 확인할 수 있음
[log]
Hibernate: create table tbl_member_roles (fno bigint not null auto_increment, role_name varchar(255), member varchar(255), primary key (fno)) engine=InnoDB
Hibernate: create table tbl_members (uid varchar(255) not null, regdate datetime, uname varchar(255), updatedate datetime, upw varchar(255), primary key (uid)) engine=InnoDB
Hibernate: alter table tbl_member_roles add constraint FKiy7scif7laghe23vht49x2aka foreign key (member) references tbl_members (uid)

8.2.2. Repository 생성
- Member가 핵심적인 역할을 하기 때문에 Repository 역시 persistence 패키지 생성하고, MemberRepository 작성

8.2.3. 테스트를 통한 데이터 추가/조회
- 테스트를 통해 테이블 간의 연관관계 설정을 좀 더 세밀하게 해 주는 것이 좋음, 테스트 폴더에 Test 클래스 생성
- 작성한 tests 클래스에 테스트에 사용할 데이터를 추가할 수 있도록 코드 추가
- 엔티티들의 영속관계를 한 번에 처리하지 못해서 에러가 발생해, 이에 대한 처리를 cascade 설정을 추가해야 함 (Member클래스)
- testInsert() 코드는 101명의 사용자를 생성, 사용자 중 user0 ~ 80 까지는 BASIC이라는 권한, user90까지는 MANAGER, 나머지 10명은 ADMIN 권한을 가지도록 설계
- 데이터베이스에 정상적으로 데이터가 추가되었으면, 회원 데이터와 함께 권한들에 대한 정보를 같이 조회할 수 있도록 조회 작업 진행
- tbl_members와 tble_members_roles 테이블을 둘 다 조회해야 하기 때문에 에러가 발생 => 즉시 로딩을 이용해 조인을 하는 방식으로 처리 (권한 정보는 회원 정보와 같이 필요한 경우가 많기 때문에, fetch 모드를 즉시 로딩으로 설정)
- testRead()를 실행하면 정상적으로 처리 확인
[log]
Hibernate: select member0_.uid as uid1_1_0_, member0_.regdate as regdate2_1_0_, member0_.uname as uname3_1_0_, member0_.updatedate as updateda4_1_0_, member0_.upw as upw5_1_0_, roles1_.member as member3_0_1_, roles1_.fno as fno1_0_1_, roles1_.fno as fno1_0_2_, roles1_.role_name as role_nam2_0_2_ from tbl_members member0_ left outer join tbl_member_roles roles1_ on member0_.uid=roles1_.member where member0_.uid=?
2020-10-07 23:33:08.388  INFO 12392 --- [           main] org.zerock.MemberTests                   : memberMember(uid=user85, upw=pw85, uname=사용자85, regdate=2020-10-07 23:27:00.0, updatedate=2020-10-07 23:27:00.0, roles=[MemberRole(fno=86, roleName=MANAGER)])





















